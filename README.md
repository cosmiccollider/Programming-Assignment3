For problem 1 of the homework, my code is able to simulate the problem provided by creating 4 threads that represent the Minotaurâ€™s servants. To represent the unordered bag that the servants will draw tags from, I created a Linked List of integers so that when a servant pulls a number, they are really drawing a gift with a Guest Tag where the number is the Tag ID. The reason I chose a Linked List was for efficiency, so that as the servants draw a tag from the bag, they are able to easily remove said tag without affecting the list too much. While designing my implementation I had originally tried to use a ConcurrentLinkedQueue, however I soon realized that this would cause problems with performance sa time went on and the list increased in size. As such I instead implemented a LazyList that would create a concurrent Linked List that could handle multiple threads and large inputs. I was able to do this by utilizing locks and synchronization on objects to keep my code consistent and correct throughout. To give into the demands of the assignment I made my code search the chain 10% of the time by using a random number and some guest tag. The requirements of the assignment did not specify how frequent a thread needed to do this or what tag had to be used so I believe my code is correct under the information given to me. Lastly, I stuck to more of the guidelines by making sure every servant alternated between adding and removing tags to the chain as per the Minotaur's demands.

For problem 2 of the homework, my code was able to simulate the given prompt by utilizing a shared memory object I called the SharedMemorySpace. This memory space would hold the highest and lowest temperatures recorded by all threads updating every 1 second. I simulated the passing of time from minutes to seconds to allow for easier testing, this way 1 hour in the prompt would be 1 minute of real time. To achieve this, I told my main thread to sleep for 1 second and notifyAll threads when it woke up. This was because every thread would accomplish its goals of measuring temperature and comparing it all in under one second. To keep everything in sync, the threads would wait and only wake up once the main thread woke up. Only allowing for one thread to access the shared memory at a time I was able to ensure the correctness of the assignment through synchronization. While this might have had an effect on efficiency, I was able to confirm that all threads could still measure and compare temperatures in under a second. This loss of efficiency caused by synchronization was pointless, since the code would have to wait for the second to end regardless.

Testing both problems, I can say that both solutions were able to meet the correctness and guidelines given to me in the assignment description. I believe I optimized my code to a reasonable amount and have valid reasons for synchronizing certain elements of my code. While this might have had an effect on performance, I believe my code made up for it as mentioned above.
